/*
 * Accounts & Users Service - Public API
 *
 * IN PROGRESS->This is the guide to use the different endpoints to manage the clusters.
 *
 * API version: 0.0.1
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
)

// Linger please
var (
	_ _context.Context
)

// OpenIDApiService OpenIDApi service
type OpenIDApiService service

type ApiGetOpenIdSessionsLogoutRequest struct {
	ctx _context.Context
	ApiService *OpenIDApiService
	idTokenHint *string
	postLogoutRedirectUri *string
	state *string
}

func (r ApiGetOpenIdSessionsLogoutRequest) IdTokenHint(idTokenHint string) ApiGetOpenIdSessionsLogoutRequest {
	r.idTokenHint = &idTokenHint
	return r
}
func (r ApiGetOpenIdSessionsLogoutRequest) PostLogoutRedirectUri(postLogoutRedirectUri string) ApiGetOpenIdSessionsLogoutRequest {
	r.postLogoutRedirectUri = &postLogoutRedirectUri
	return r
}
func (r ApiGetOpenIdSessionsLogoutRequest) State(state string) ApiGetOpenIdSessionsLogoutRequest {
	r.state = &state
	return r
}

func (r ApiGetOpenIdSessionsLogoutRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GetOpenIdSessionsLogoutExecute(r)
}

/*
 * GetOpenIdSessionsLogout Initialize & Complete User Logout
 * This endpoint initiates and completes user logout at ORY Hydra and initiates OpenID Connect Front-/Back-channel logout.<br/>
A logout request may be initiated by the OpenID Provider (OP - **you**) or by the Relying Party (RP - the OAuth2 Client):
- The OP-initiated flow does not need an `id_token_hint`, and it may neither define a state nor a `post_logout_redirect_uri`. (**You need a valid session cookie!!**)
- The RP-initiated flow needs an `id_token_hint` and may optionally define state and `post_logout_redirect_uri`.<br/>
Before the logout is completed, the user is redirected to the Logout UI to confirm the logout request.<br/>
There are several possible pathways for executing this flow, explained in the following diagram:<br/><br/>
<center><img width="60%" src="https://mermaid.ink/img/eyJjb2RlIjoiZ3JhcGggVEQ7XG4gICAgSVtHRVQgL29hdXRoMi9zZXNzaW9uL2xvZ291dF0tLT58aGFzIGlkX3Rva2VuX2hpbnQqfFJQSVtSUC1pbml0aWF0ZWQgbG9nb3V0XTtcbiAgICBJW0dFVCAvb2F1dGgyL3Nlc3Npb24vbG9nb3V0XS0tPnxkb2VzIG5vdCBoYXZlIGlkX3Rva2VuX2hpbnQqfE9QSVtPUC1pbml0aWF0ZWQgbG9nb3V0XVxuT1BJLS0-fGhhcyBzdGF0ZSp8RVtFcnJvcl1cbk9QSS0tPnxoYXMgcG9zdF9sb2dvdXRfdXJpKnxFW0Vycm9yXVxuT1BJLS0-fGhhcyB2YWxpZCBzZXNzaW9uIGNvb2tpZXxMVUlbTG9nb3V0IFVJIHdpdGggP2xvZ291dF9jaGFsbGVuZ2U9Li4uXVxuT1BJLS0-fGhhcyBubyB2YWxpZCBzZXNpb24gY29va2llfEVuZFtSZXR1cm4gdG8gcG9zdF9sb2dvdXRfdXJsKioqXVxuUlBJLS0-fGhhcyBhY3RpdmUgc2Vzc2lvbioqKip8TFVJXG5SUEktLT58bm8gYWN0aXZlIHNlc3Npb24qKioqfFJQSTJcbkxVSS0tPnx2ZXJpZnkgbG9nb3V0IHJlcXVlc3R8TFVJXG5MVUktLT58cmVkaXJlY3Qgd2l0aCBsb2dvdXRfdmVyaWZpZXIqfFJQSTJbIC9vYXV0aDIvc2Vzc2lvbnMvbG9nb3V0P2xvZ291dF92ZXJpZmllcj0uLi5dXG5SUEkyLS0-fGV4ZWN1dGUgZnJvbnQvYmFja2NoYW5uZWwgbG9nb3V0LCByZXZva2UgY29va2llfFJQSTJcblJQSTItLT58UmVkaXJlY3QgdG98RW5kIiwibWVybWFpZCI6eyJ0aGVtZSI6ImRlZmF1bHQifX0"></center><br/>
**Legend**:
- **\***: This is a query parameter, for example <b>/oauth2/sessions/logout?id_token_hint=...</b>
- **\*\*** Here, an **"active session"** implies that there has been at least one login request completed with `remember: true` for that user.
If that's not the case, the system **"does not know"** what to do (because there has never been a session issued that was remembered - hence it's not possible to forget it).
- **\*\*\***: Here, the **"valid session cookies"** implies that the browser has a valid authentication cookie when calling `/oauth2/sessions/logout`.
If you have problems at this step, check if there is a cookie `oauth2_authentication_session` for the domain ORY Hydra is running at!!
- **\*\*\*\***: The `post_logout_redirect` defaults to the configuration value of `urls.post_logout_redirect`.
If it's an RP-initiated flow and a `post_logout_redirect_uri` was set and that URL is in the array of the OAuth2 Client's `urls.post_logout_redirect`, the browser will be redirected there instead.

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetOpenIdSessionsLogoutRequest
 */
func (a *OpenIDApiService) GetOpenIdSessionsLogout(ctx _context.Context) ApiGetOpenIdSessionsLogoutRequest {
	return ApiGetOpenIdSessionsLogoutRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 */
func (a *OpenIDApiService) GetOpenIdSessionsLogoutExecute(r ApiGetOpenIdSessionsLogoutRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OpenIDApiService.GetOpenIdSessionsLogout")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/oauth2/sessions/logout"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.idTokenHint != nil {
		localVarQueryParams.Add("id_token_hint", parameterToString(*r.idTokenHint, ""))
	}
	if r.postLogoutRedirectUri != nil {
		localVarQueryParams.Add("post_logout_redirect_uri", parameterToString(*r.postLogoutRedirectUri, ""))
	}
	if r.state != nil {
		localVarQueryParams.Add("state", parameterToString(*r.state, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetOpenIdUserInfoRequest struct {
	ctx _context.Context
	ApiService *OpenIDApiService
}


func (r ApiGetOpenIdUserInfoRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GetOpenIdUserInfoExecute(r)
}

/*
 * GetOpenIdUserInfo Get the Payload of the ID Token.
 * This endpoint returns the payload of the ID Token, including the idTokenExtra values, of the provided OAuth 2.0 Access Token.<br/>
**NOT all info of this example is really included, this endpoint is high customizable, this is need added in the backend!**

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetOpenIdUserInfoRequest
 */
func (a *OpenIDApiService) GetOpenIdUserInfo(ctx _context.Context) ApiGetOpenIdUserInfoRequest {
	return ApiGetOpenIdUserInfoRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 */
func (a *OpenIDApiService) GetOpenIdUserInfoExecute(r ApiGetOpenIdUserInfoRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OpenIDApiService.GetOpenIdUserInfo")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/userinfo"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/jwt", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
